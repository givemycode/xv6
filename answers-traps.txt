1、在传递整数参数时，如果参数个数少于8个，
   它们都会被放置在a0-a7中进行传递，其中a0-a1还可以保存返回值。
   在对printf的调用中，13保存在a2中，由汇编代码中main函数中的li a2,13可以看出。
2、从上述的汇编代码中可以看到，编译器直接将对f函数的调用结果硬编码到了代码中，这样可以极大程度地减少函数调用过程的开销。
   在C代码中，main调用f，f调用g。而在生成的汇编中，main函数进行了内联优化处理。
   从代码li a1,12可以看出，main直接计算出了结果并储存。
3、在汇编文件中去查找，是0x630。
4、auipc ra,0x0：这行代码将0x0左移12位（还是0x0）加到PC（当前为0x30）上并存入ra中，
                 即ra中保存的是0x30。
   jalr  1536(ra)：ra中保存的是0x30；
                   跳转地址 = ra + 1528 = 0x30 + 0x600 = 0x630；
                   ra = PC + 4 = 0x38。
5、%x表示以十六进制形式输出整数，因此首先将57616转为16进制数，为0xe110。
   %s表示按照字符的格式读取字符并输出，直到读取到 ‘\0’ 为止。
   RISC-V是小端字节序，因此在内存中存储的形式为0x726c6400。
   对应的ASCII值为0x72=‘r’，0x6c=‘l’，0x64=‘d’，0x00=‘\0’。
   因此最后printf输出的结果为"He110, World\0"。
   不需要修改57616，大小端存放并不会改变它转化为16进制数之后的结果。
   i需要进行反转，即i=0x726c6400。
6、 printf需要接收2个参数，将第一个参数3放在a1中，第二个参数放在a2中。
    由于没有第二个参数，所有直接输出寄存器a2中的值。